
The workflow is depicted in Figure \ref{fig:protocol}, and described with full details as follows.

\begin{figure}[h]
	\centering
		\includegraphics[width=390pt,draft=false]{images/protocol.eps}
	\caption{Overview of the protocol messages exchanged between the user, the Dusk Network, and the SP.}
	\label{fig:protocol}
\end{figure}

\begin{enumerate}
	\item (\textbf{user}) $\mathsf{send\_license\_req}$ : Compute a license public key $(\lpk, R)$ belonging to the user, using the user's own public key, and also an additional key $\ksym_{\License} = \hb(\lsk)G$, by computing first the user's $\lsk$. Then, compute $(\rpk, R)$ and $\kdh$ using the SP's public key. And finally send the following request to the network:


		$$\Request = ((\rpk, R), \enc, \nonce)$$

	where 

		$$\enc = \Enc_{\kdh} ((\lpk, R)||\ksym_{\License}; \nonce)$$


	\item (\textbf{SP}) $\mathsf{get\_license\_req}$ : Continuously check the network for incoming license requests.

	\item (\textbf{SP}) $\mathsf{send\_license}$ : Upon receiving the request from a user, define a set of attributes $\attr$ representing the license, and compute a digital signature as follows:

		$$\lsig = \sign_{\sk_{\SP}}(\lpk, \attr)$$

	Then, send the following license to the network:

		$$\License = ((\lpk, R), \enc, \nonce, \pos)$$

	where 

		$$\enc = \Enc_{\ksym_{\License}} (\lsig || \attr; \nonce)$$

	\item (\textbf{user}) $\mathsf{get\_license}$ : Receive the license by scanning the incoming transactions.

	\item (\textbf{user}) $\mathsf{call\_nullify\_license}$ : When desiring to use the license, nullify it by executing a call to the license contract. The following steps are performed:

	\begin{itemize}
		\item The user issues a transaction that calls the license contract, which includes a ZKP that is computed out of the gadget depicted in Figure \ref{fig:circuit_prove_nft}.
		\item The network validators will execute the smart contract, which verifies the proof. Upon success, the following session will be added to a shared list of sessions:

			$$\Session = \{(\spk, R), \lnullifier, \com_0^{hash}, \com_1, \com_2\}$$

		where $(\spk, R)$ is a stealth address included into the transaction, and computed by the user using the SP's public key.


	\end{itemize}

	\item (\textbf{SP}) $\mathsf{get\_session}$ : Receive the session by scanning the incoming transactions.

	\item (\textbf{user}) $\mathsf{req\_service}$ : Request the service to the SP, establishing communication using a secure channel, and providing the $\SessionCookie$.

	\item (\textbf{SP}) $\mathsf{grant\_service}$ : Grant or deny the service upon verification of the following steps:

	\begin{itemize}
		\item Check whether or not the values $(\attr, \pk_{\SP}, c)$ included in the $\SessionCookie$ are correct.
		\item Check whether or not the openings $((\pk_{\SP}, \mathsf{s_0}), (\attr, \mathsf{s_1}), (c, \mathsf{s_2}))$ included in the $\SessionCookie$ match the commitments $\com_0^{hash}, \com_1, \com_2$ found in the $\Session$, where $\Session.\lnullifier = \SessionCookie.\lnullifier$.
	\end{itemize}

\end{enumerate}

\begin{figure}[h]
	\centering
	\setlength{\fboxsep}{5pt}%
	\setlength{\fboxrule}{0.3pt}%
	\fbox{
		\includegraphics[width=460pt,draft=false]{images/circuit_prove_nft.eps}}
	\caption{Arithmetic circuit for proving a license's ownership.}
	\label{fig:circuit_prove_nft}
\end{figure}

Furthermore, the SP might request the user to nullify the license they are using (i.e. this is a single-use license, like entering a concert). This is done through the computation of $\lnullifier$. The deployment of this part of the circuit has two different possibilities:
\begin{itemize}
	\item If we set $c = 0$ (or directly remove this input from the circuit), the license will be able to be used only once.
	\item If the SP requests the user to set a custom value for $c$ (e.g. the date of an event), the license will be able to be reused only under certain conditions.
\end{itemize}

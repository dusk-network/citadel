% !TeX root = ../build/main.tex

\subsubsection{Transfer circuit} \label{sec:transfer-circuit}

The method $\hlget{\cTransfer}$ requires the verification of a zero-knowledge proof of satisfiability of the following circuit.\\

Inputs (private, unless stated otherwise):
\begin{itemize}
	\item Miscellaneous:
	\begin{itemize}
		\item (public) $\sc$.
		\item Swap data commitment $\com[\swap]$. 
	\end{itemize}
	\item Merkle tree roots:
	\begin{itemize}
		\item (public) Recent securities root $\root[\securities]$.
		\item (public) Allowlist root $\tree[\holders].\root$.
	\end{itemize}
	\item Auditor data:
	\begin{itemize}
		\item (public) Auditor public key $\pk[\auditor]$.
	\end{itemize}
	\item Input data. For $i=1,2$:
	\begin{itemize}
		\item Content of input securities $\content{\vin}_i = (\val[\vin]_i \conc \pk[\sender]_i.\spend)$.
		\item Positions $\pos[\securities]_i$ of securities in the Merkle tree of securities, and their corresponding Merkle proofs $\proof[\securities]_i$.
		\item Positions $\pos[\sender]_i$ of the sender public keys $\pk[\sender]_i.\spend$ in the Merkle tree of holders, and their corresponding Merkle proofs $\proof[\sender]_i$.
		\item Signatures $\sign_i$ to authorize spending.
		\item Nullifier keys $\sk[\sender]_i.\nullify = (\sk[\sender]_i.\nullify.\token, \sk[\sender]_i.\nullify.\proof)$.
		\item (public) Nullifiers $\nul_i$.
		\item Symmetric keys $\k[\auditor-\vin]_i$ shared with auditor. 
		\item (public) Auditor encryption $\enc[\auditor-\vin]_i$.
		\item Bitmask $\bitmask[\vin]_i$.
		\item Blinders $\blinder[\com-\vin]_i, \blinder[\auditor-\vin]_i$.
	\end{itemize}
	\item Output data. For $i=3,4$:
	\begin{itemize}
		\item Content of output securities $\content{\vout}_i = (\val[\vout]_i \conc \pk[\recipient]_i.\spend)$.
		\item Recipient's public view keys $\pk[\recipient].\view$.
		\item Positions $\pos[\recipient]_i$ of recipient's public keys $\pk[\recipient]_i.\spend$ in the Merkle tree of holders, and their corresponding Merkle proofs $\proof[\recipient]_i$.
		\item (public) Output commitments $\com_i$.
		\item Symmetric keys $\k[\recipient]_i$ shared with recipient. 
		\item (public) Output encryptions $\enc[\recipient]_i$.
		\item Symmetric keys $\k[\auditor-\vout]_i$ shared with auditor. 
		\item (public) Auditor encryption $\enc[\auditor-\vout]_i$.
		\item Bitmask $\bitmask[\vout]_i$.
		\item Blinders $\blinder[\com-\vout]_i, \blinder[\recipient]_i, \blinder[\auditor-\vout]_i$.
	\end{itemize}
\end{itemize}

Constraints: 
\begin{itemize}
	\item Input securities. For $i=1,2$:
	\begin{itemize}
		\item Input spending. 
		\begin{itemize}
			\item $\accept = \hlget{\MT.\Verify}_{\pp}(\hlget{\Com}(\content{\vin}_i; \blinder[\com-\vin]_i), \pos[\securities]_i, \root[\securities], \proof[\securities]_i)$.
			\item $\accept = \hlget{\MT.\Verify}_{\pp}(\pk[\sender]_i.\spend, \pos[\sender]_i, \tree[\holders].\root, \proof[\sender]_i)$.
			\jsi{All trees should in principle have different $\pp$.}
			\item $\accept = \hlget{\SS.\Verify}_{\pk[\sender]_i.\spend}(\msg, \sign_i)$, where
				\[\msg = \begin{cases}
				(\sc, \hlget{\Com}(\transferdata)),  				& \quad \text{ if } \sc.\length = 1; \\
				(\sc, \hlget{\Com}(\transferdata), \com[\swap]),	& \quad \text{ if } \sc.\length = 3; \\
				\end{cases}\]
				and
				\[ \transferdata = \left( \begin{aligned}
					& (\bitmask[\vin]_i \land (\content{\vin}_i, \blinder[\com-\vin]))_{i=1,2}, \\
					& (\bitmask[\vout]_i \land (\content{\vout}_i, \blinder[\com-\vout]))_{i=3, 4}
				\end{aligned} \right). \]
		\end{itemize}
		\item Nullifiers. 
		\begin{itemize}
			\item $\nul_i = \hlget{\NN.\Nul}(\pos[\securities]_i \conc \sk[\sender]_i.\nullify.\token)$.
			\item $\accept = \hlget{\NN.\Verify}(\pk[\sender]_i.\spend, \sk[\sender]_i.\nullify.\token, \sk[\sender]_i.\nullify.\proof)$.
		\end{itemize}
		\item Range check.
		\begin{itemize}
			\item $\val[\vin]_i < \val[\vmax]$.
			\jsi{Actually each one should be a bit lower, I think, to prevent that the sum overflows.}
			\dki{The maximum value should be far smaller than the field size, preferably 128 bits. It is also should be $\leq$ rather
			than $<$}
		\end{itemize}
		\item Auditor-related constraints.
		\begin{itemize}
			\item $(\enc[\auditor-\vin]_i, \k[\auditor-\vin]) = \hlget{\Enc}_{\pk[\auditor]}(\pos[\securities]_i \conc \sk[\sender]_i.\nullify.\token; \blinder[\auditor-\vin])$. 
		\end{itemize}
	\end{itemize}
	\item Output securities. For $i=3,4$:
	\begin{itemize}
		\item Output spending. 
		\begin{itemize}
			\item $\accept = \hlget{\MT.\Verify}_{\pp}(\pk[\recipient]_i.\spend, \pos[\recipient]_i, \tree[\holders].\root, \proof[\recipient]_i)$.
			\item $\com_i = \hlget{\Com}(\content{\vout}_i; \blinder[\com-\vout]_i)$.
			\item $(\enc[\recipient]_i, \k[\recipient]_i) = \hlget{\Enc}_{\pk[\recipient]_i.\view}(\content{\vout}_i \conc \blinder[\com-\vout]_i; \blinder[\recipient]_i)$.
			\jsi{All trees should in principle have different $\pp$.}
		\end{itemize}
		\item Range check.
		\begin{itemize}
			\item $\val[\vin]_i < \val[\vmax]$.
			\jsi{Actually each one should be a bit lower, I think.}
			\dki{The maximum value should be far smaller than the field size, preferably 128 bits. It is also should be $\leq$ rather
			than $<$}
		\end{itemize}
		\item Auditor-related constraints.
		\begin{itemize}
			\item $(\enc[\auditor-\vout]_i, \k[\auditor-\vout]_i) = \hlget{\Enc}_{\pk[\auditor]}(\k[\recipient]_i; \blinder[\auditor-\vout])$. 
		\end{itemize}
	\end{itemize}
	\item Input-output consistency:
	\begin{itemize}
		\item Balance check.
		\begin{itemize}
			\item $\sum_{i=1}^2 \val[\vin]_i = \sum_{i=3}^4 \val[\vout]_i$.
		\end{itemize}
	\end{itemize}
\end{itemize}    

\begin{figure}
	\begin{center}
		\includegraphics[scale=0.068]{../circuit-diagram/zedger_minimal_circuit.png}
		\caption{Zedger transfer circuit. \jsi{outdated}}
	\end{center}
\end{figure}


\subsubsection{Swap circuit} \label{sec:swap-circuit}

\noindent Inputs (private, unless stated otherwise):

\begin{itemize}
	\item Miscellaneous:
	\begin{itemize}
		\item (public) $\sc$.
		\item Swap exchange rate $a, b$.
	\end{itemize}
	\item Input data. 
	\begin{itemize}
		\item Commitments to the transfer from the maker: $\com[\maker-\transfer]$.
		\item Commitments to the transfer from the taker: $\com[\taker-\transfer]$.
		\item Signature from the maker: $\sign^\maker$.
		\item Signature from the taker: $\sign^\taker$.
	\end{itemize}
	\item Output data. For $\fio$:
	\begin{itemize}
		\item Content of output securities: $\content{}_{\xi} = (\val_{\xi} \conc \pk[\recipient]_{\xi}.\spend)$, for $x = \seca, \secb$.
		\item (public) Commitment of output securities: $\com_{\xi}$ for $x = \seca, \secb$.
		\item Blinders of commitments to securities: $\blinder[\com]_{\xi}$, for $x = \seca, \secb$.
	\end{itemize}
\end{itemize}

\noindent Constraints:

\begin{itemize}
	\item Ownership of new securities. For $\fii$:
		\begin{itemize}
			\item $\pk[\recipient]_{\ai}.\spend = \pk[\recipient]_{\bi}.\spend$.
		\end{itemize}
	\item Commitments:
		\begin{itemize}
			\item $\com[\maker-\swap] = \hlget{\Com}(a, b, \pk[\recipient]_{\seca, 2}.\spend)$.
			\item $\com[\taker-\swap] = \hlget{\Com}(\val_{\seca, 1}, \val_{\secb, 2}, \pk[\recipient]_{\seca, 1}.\spend)$.
		\end{itemize}
	\item Exchange rate:
		\begin{itemize}
			\item Range check: $a,b\leq MAX\_PRICE\_PRECISION$;
			\item $a \cdot \val_{\seca, 1} \leq b \cdot \val_{\secb, 2}$.
		\end{itemize}
	\item Output security commitments. For $\fio$ and $x = \seca, \secb$:
		\begin{itemize}
			\item $\com_{\xi} = \hlget{\Com}(\content{}_{\xi}; \blinder[\com]_{\xi})$ for $\fs$ and $\fio$.
		\end{itemize}
	\item Signatures.
		\begin{itemize}
			\item $\accept = \hlget{\SS.\Verify}_{\pk[\maker].\spend} (\msg[\maker], \sign^\maker)$, 
			where 
			\[\msg[\maker] = \left(\sc[1,2,3] \conc \com[\maker-\transfer] \conc \com[\maker-\swap] \right).\]
			\item $\accept = \hlget{\SS.\Verify}_{\pk[\taker].\spend} (\msg[\taker], \sign^\taker)$,
			where 
			\[\msg[\taker] = \left(\sc[3,2,1] \conc \com[\taker-\transfer] \conc \com[\taker-\swap] \right).\]
		\end{itemize}
\end{itemize}
% !TeX root = ../build/main.tex

In this section, we detail the cryptographic primitives used in Citadel. We briefly introduce Merkle trees, the commitment scheme, encryption scheme, proof system, elliptic curves and hash functions used, specifying at each step the concrete parameters with which each of the primitives is instantiated.

\paragraph{Notation.} Throughout the document, we use the following conventions. Given a set $S$, we denote sampling an element $x$ uniformly at random from $S$ by $x\gets S$. Any group $\G$ used is of a large prime order, and we assume that the discrete logarithm problem is hard in $\G$. If two elements are denoted by the same letter in upper case and lower case, e.g. $a, A$, this often signifies the fact that $A$ is a public key corresponding to the secret key $a$. 
%By $\{0,1\}^*$, we denote all bitstrings of arbitrary length.\mb{Add $\F_p$ and $\F_p^*$ notation.}

\subsection{Elliptic curves}\label{sec:elliptic_curves}

BLS12-381~\cite{zcashBLS} and Jubjub~\cite{zcashJubJub} are the elliptic curves used. More precisely, let
\[\begin{array}{lll}
	& q = & 4002409555221667393417789825735904156556882819939007885332058136 \\
	& & 124031650490837864442687629129015664037894272559787,\\
	\\
	& p = & 5243587517512619047944774050818596583769055250052763782260365869 \\
	& & 9938581184513.
\end{array}\]
Note that both are prime numbers, with bit-lengths $381$ and $255$, respectively. The curve BLS381-12 is the curve over $\mathbb{F}_q$ defined by the equation
\[E: Y^2 = X^3 + 4.\]
We have that $E(\mathbb{F}_q)$ has different subgroups $\G_1, \G_2$ such that $\#\G_1 = \#\G_2 = p$. This curve is pairing-friendly (with embedding degree $k=12$), so pairings are efficiently computable. More precisely, Citadel makes use of the bilinear group 
\[\mathbb{B}=\left( p, \G_1, \G_2, \G_T, e: \G_1\times\G_2 \rightarrow \G_T \right).\]

By instantiating the zk-SNARK with the bilinear group $\mathbb{B}$, we are be able to prove statements about satisfiability of arithmetic circuits over $\mathbb{F}_p$, the so-called \emph{scalar field} of $E$. 

Furthermore, we are interested in proving certain operations with the zk-SNARK, like the correct verification of a Schnorr signature $\sigma$. Note that $\sigma$ is an element of a certain elliptic curve $J$, but is represented as two coordinates in the base field $\F_s$ of $J$. Therefore, the verification can be best represented as arithmetic constraints modulo $s$. While it is possible to represent any NP statement using arithmetic modulo $p$ to plug it into the zk-SNARK, this incurs into a significant efficiency loss if not done carefully. The natural thing is to set $s=p$. Therefore, the signature scheme must be instantiated with an elliptic curve over $\mathbb{F}_p$. For this, let
\[d = -\frac{10240}{10241} \bmod{p}.\]
Citadel uses the Jubjub curve, defined by the equation
\[J : -X^2+Y^2 = 1 + dX^2Y^2,\]
over $\mathbb{F}_p$. In particular, it uses a subgroup $\mathbb{J}$ of order
\[\begin{array}{lll}
	& t = & 6554484396890773809930967563523245729705921265872317281365359162 \\
	& & 392183254199,\\
\end{array}\]
which is a $252$-bit prime. 

The primes and groups defined here will be used through the rest of the document.

\subsection{Digital signatures}\label{sec:signatures}

The Schnorr Sigma protocol~\cite{schnorr1989efficient} is used, compiled with the Fiat--Shamir transformation~\cite{fiat1986prove,pointcheval1996security}, as a signature scheme. 
In particular, Citadel makes use of the standard scheme as well as a double-key version to be able to delegate computations later in the protocol. Let $G, G'\gets \mathbb{J}$.

The single-key signature scheme is as follows.

\begin{itemize}
	\item \emph{Setup.} Sample a secret key $\sk \gets \F_t$ and set the corresponding public key $\pk = \sk G$. Output $(\sk, \pk)$. 
	\item \emph{Sign.} On input a message $m$ and a secret key $\sk$, sample $r \gets \F_t$ and compute $R = rG$. Compute the challenge $c = H(m, R)$, and set 
	\[u = r - c \sk.\]
	Output the signature $\sigma = (R, u)$. 
	\item \emph{Verify.} On input a public key $\pk$, message $m$ and signature $\sigma = (R, u)$, compute $c = H(m, R)$ and check whether the following equality holds:
	\[\begin{aligned}
		& R = uG + c \pk, \\
	\end{aligned}\]
	If so, accept the signature, otherwise reject.
\end{itemize}

The double-key signature scheme is as follows.

% \mbi{Consider changing $\nsk, \npk$ to $a, A$.}\jsi{Thought about it, but the problem I see is that $a,A$ have a specific meaning in the protocol, which is different from what would be their meaning here. Maybe $h,H$ or $k,K$? But I'm not sure I like these.}
\begin{itemize}
	\item \emph{Setup.} Sample a secret key $\sk \gets \F_t$ and set the corresponding public key $(\pk, \pk') = (\sk G, \sk G')$. Output $(\sk, (\pk, \pk'))$. 
	\item \emph{Sign.} On input a message $m$ and a secret key $\sk$, sample $r \gets \F_t$ and compute $(R, R') = (rG, rG')$. Compute the challenge $c = H(m, R, R')$, and set 
	\[u = r - c \sk.\]
	Output the signature $\sigma = (R, R', u)$. 
	\item \emph{Verify.} On input a public key $\pk$, message $m$ and signature $\sigma = (R, R', u)$, compute $c = H(m, R, R')$ and check whether the following equalities hold:
	\[\begin{aligned}
		& R = uG + c \pk, \\
		& R' = uG' + c \pk'. \\
	\end{aligned}\]
	If so, accept the signature, otherwise reject.
\end{itemize}

\jsi{The computation of the challenge requires $\F_t$ operations, while we are working on an $\F_p$-circuit. If we are doing tricks to circumvent this, it should be reflected and analyzed in the present document. Also, check what is the code doing.\\}

The signature scheme is existentially unforgeable under chosen-message attacks under the discrete logarithm assumption, in the random oracle model~\cite[Section 12.5.1]{katz2020introduction}. While the Schnorr signature scheme is widely known, the double-key version has not been used before, to the best of our knowledge. In Citadel, as it happens in the Phoenix transaction model \cite{phoenix-doc}, this is leveraged to allow for delegation of proof computations without the need to share one's secret key with the helper.

\subsection{Hash functions}\label{sec:hash_functions}

Citadel uses hash functions $H$ mostly in the case where given $y$, we want to prove knowledge of $x$ such that $H(x)=y$. We will do so with PlonK, which requires statements to be written as arithmetic constraints modulo a large prime number $p$. Most hash function evaluations do not naturally translate to this language, incurring in a big efficiency loss. 
%
To avoid this, the Poseidon hash function~\cite{grassi2021poseidon} $H:\mathfrak{F}_p\rightarrow \F_p$, where $\mathfrak{F}_p$ is the set of tuples of $\F_p$-elements of any length, will be used whenever we compute a hash of which we need to produce a proof. This is because Poseidon is purposefully designed to work with modular arithmetic. 

\subsection{Encryption schemes}\label{sec:encryption}

A symmetric encryption scheme~\cite{duskDmitry} based on Poseidon is also used, as described below.

Poseidon is built by applying the sponge construction~\cite{bertoni2011cryptographic} to a permutation $\pi : \F_p^t \rightarrow \F_p^t$, for $t=r+c$, where
\begin{itemize}
	\item $r$ is the \emph{rate}, i.e. the amount of $\F_p$-elements of the input that can be processed in a call to $\pi$.
	\item $c$ is the \emph{capacity}, which is a part of the permutation that is never output by the hash, and is required for security.
\end{itemize}
The permutation $\pi$ is composed of linear (matrix multiplication over $\mathbb{F}_p$) and non-linear (S-boxes) operations. Some rounds are \emph{full rounds}, and apply S-boxes to the whole input, and others are \emph{partial rounds}, in which an S-box is applied to a single $\F_p$-element.

In this case, Citadel uses \textsc{Poseidon}-128 to target 128-bit security. Following the recommendations of~\cite{grassi2021poseidon}, parameters are set as $r=4$ and $c=1$, so that a hash in the Merkle tree can be computed with a single call to the permutation. Internally, a permutation performs $R_F=8$ full rounds and $R_P=59$ partial rounds, and uses $S(x)=x^5$ as the S-box.

When no proofs involving hashes are required, the BLAKE2 family of hash functions~\cite{rfc7693} is used, which yields better efficiency. In particular, the BLAKE2b hash function is used, since it is optimized for 64-bit platforms.

The encryption scheme~\cite{duskDmitry} is a variation of the one-time pad encryption in the field. It uses Poseidon as a pseudorandom function to extend an agreed-upon symmetric key and encrypt the message. Therefore, the encryption scheme is perfectly secure under the random oracle model. 

Concretely, the encryption works as follows. Given a message in $\mathbb{F}_q^{\ell}$, each $\mathbb{F}_q$-component is added to  the corresponding component of the key. The key is obtained using Poseidon by extending the symmetric-encryption key, which is an elliptic curve point, 
to obtain a key with the same size of the message. The initialization vector contains the two coordinates of the key and a nonce, it is passed to the Poseidon iteration which extends the key and outputs the ciphertext. The sender sends the encryption along with the nonce and the information needed to compute the key, so the receiver can use Poseidon with the same key and nonce to decrypt the message.

\subsection{Commitments}

As commitment scheme, Citadel uses the Pedersen commitment.

\mbi{TODO: describe the Pedersen commitment scheme.}

\subsection{Proof systems}\label{sec:proof_system}

Citadel uses the zk-SNARK PlonK~\cite{gabizon2019plonk} as its proof system. PlonK allows anyone to prove satisfiability of any arithmetic circuit modulo a prime. Since arithmetic circuit satisfiability is an NP-complete problem, this proof system will allow us to prove any statement in NP. 
%
PlonK makes use of the KZG polynomial commitment scheme~\cite{kate2010constant}, as described in~\cite{gabizon2019plonk}. This requires instantiating PlonK over a pairing-friendly group, which is described in Section~\ref{sec:elliptic_curves}.

Below is a summary the efficiency of PlonK, for a circuit with $n$ multiplication gates and $\ell$ public inputs.
\begin{itemize}
	\item \emph{Proving time:} $O(n)$ group and field operations. 
	\item \emph{Verification time:} $O(1+\ell)$ group and field operations.
	\item \emph{Proof size:} $O(1)$ group and field elements.
\end{itemize}

PlonK is sound in the algebraic group model~\cite{fuchsbauer2018algebraic}, and statistically zero-knowledge. A complete and explicit description of the scheme can be found in~\cite[Section~8]{gabizon2019plonk}.

\subsection{Merkle trees}\label{sec:merkle_trees}

A \emph{Merkle tree}~\cite{merkle1987digital} is a tree that contains at every vertex the hash of its children vertices. More precisely, we consider a perfect $k$-ary tree of height $h$. The single vertex at level $0$ is called the \emph{root} of the tree, and the $k^{h}$ vertices at level $h$ are called the \emph{leaves}. Given a vertex in level $i$, the $k$ vertices in level $i+1$ that are adjacent to it are called its \emph{children}. Two vertices are each other's \emph{sibling} if they are children of the same vertex.

To each vertex in the tree, we will recursively associate a value, starting from the leaves.\footnote{We will often abuse notation and write the vertex to refer to the value associated with the vertex.} Let $H$ be a hash function. 
\begin{itemize}
	\item Level $h$: leaves are initialized to a null value. Through the lifetime of the tree, they will progressively be filled from left to right with values.
	\item Level $0\leq i <h$: each vertex has $k$ children $c_1,\dots, c_k$ at level $i+1$. We set the value of the vertex to $H({c_1}, \dots, {c_k})$. 
\end{itemize}

The tree is updated every time a new value is written into a leaf, by updating the $h+1$ elements in the path from the new value to the root. In particular, this means that the root changes after every update. A nice feature of Merkle trees is that, given a root $r$, it is easy to prove that a value $x$ is in a leaf of a tree with root $r$. The proof works as follows: 
\begin{itemize}
	\item \emph{Prove.} For $i=h,\dots,1$, let $x_i$ be the vertex that is in level $i$ and is in the unique path from $x$ to the root. Let $y_{i, 1},\dots, y_{i, k-1}$ be the $k-1$ siblings of $x_i$. Output
	\[(x, (y_{1,1}, \dots, y_{1,k-1}), \dots, (y_{h,1},\dots,y_{h,k-1})).\]
	\item \emph{Verify}. Parse input as $(x_h, (y_{1,1}, \dots, y_{1,k-1}), \dots, (y_{h,1},\dots,y_{h,k-1}))$, where $x_h$ is the purported value and $y_{i,1},\dots,y_{i,k-1}$ are the purported siblings at level $i$. For $i=h-1,\dots, 0$, compute\footnote{To be precise, the prover also has to send $\lceil\log_2k\rceil$ bits for each level, specifying the position of $x_i$ with respect to its siblings, so that the verifier knows in which order to arrange the inputs of the hash.}
	\[x_i = H\left( x_{i+1}, y_{i+1,1},\dots,y_{i+1,k-1} \right).\] 
\end{itemize}

This allows for proving membership in a set of size $k^h$ by sending $O(kh)$ values. This proof is sound provided that the hash function is collision resistant~\cite[Section 5.6.2]{katz2020introduction}. For our application, we will set $k=4$ and $h=17$.